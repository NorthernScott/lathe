"""
This type stub file was generated by pyright.
"""

from scipy.sparse.linalg._interface import LinearOperator

"""
Sparse matrix functions
"""
__all__ = ['expm', 'inv', 'matrix_power']
UPPER_TRIANGULAR = ...
def inv(A): # -> csc_array | Any:
    """
    Compute the inverse of a sparse arrays

    Parameters
    ----------
    A : (M, M) sparse arrays
        square matrix to be inverted

    Returns
    -------
    Ainv : (M, M) sparse arrays
        inverse of `A`

    Notes
    -----
    This computes the sparse inverse of `A`. If the inverse of `A` is expected
    to be non-sparse, it will likely be faster to convert `A` to dense and use
    `scipy.linalg.inv`.

    Examples
    --------
    >>> from scipy.sparse import csc_array
    >>> from scipy.sparse.linalg import inv
    >>> A = csc_array([[1., 0.], [1., 2.]])
    >>> Ainv = inv(A)
    >>> Ainv
    <Compressed Sparse Column sparse array of dtype 'float64'
        with 3 stored elements and shape (2, 2)>
    >>> A.dot(Ainv)
    <Compressed Sparse Column sparse array of dtype 'float64'
        with 2 stored elements and shape (2, 2)>
    >>> A.dot(Ainv).toarray()
    array([[ 1.,  0.],
           [ 0.,  1.]])

    .. versionadded:: 0.12.0

    """
    ...

class MatrixPowerOperator(LinearOperator):
    def __init__(self, A, p, structure=...) -> None:
        ...
    
    @property
    def T(self): # -> MatrixPowerOperator:
        ...
    


class ProductOperator(LinearOperator):
    """
    For now, this is limited to products of multiple square matrices.
    """
    def __init__(self, *args, **kwargs) -> None:
        ...
    
    @property
    def T(self): # -> ProductOperator:
        ...
    


class _ExpmPadeHelper:
    """
    Help lazily evaluate a matrix exponential.

    The idea is to not do more work than we need for high expm precision,
    so we lazily compute matrix powers and store or precompute
    other properties of the matrix.

    """
    def __init__(self, A, structure=..., use_exact_onenorm=...) -> None:
        """
        Initialize the object.

        Parameters
        ----------
        A : a dense or sparse square numpy matrix or ndarray
            The matrix to be exponentiated.
        structure : str, optional
            A string describing the structure of matrix `A`.
            Only `upper_triangular` is currently supported.
        use_exact_onenorm : bool, optional
            If True then only the exact one-norm of matrix powers and products
            will be used. Otherwise, the one-norm of powers and products
            may initially be estimated.
        """
        ...
    
    @property
    def A2(self): # -> Any:
        ...
    
    @property
    def A4(self): # -> Any:
        ...
    
    @property
    def A6(self): # -> Any:
        ...
    
    @property
    def A8(self): # -> Any:
        ...
    
    @property
    def A10(self): # -> Any:
        ...
    
    @property
    def d4_tight(self): # -> floating[Any]:
        ...
    
    @property
    def d6_tight(self): # -> floating[Any]:
        ...
    
    @property
    def d8_tight(self): # -> floating[Any]:
        ...
    
    @property
    def d10_tight(self): # -> floating[Any]:
        ...
    
    @property
    def d4_loose(self): # -> floating[Any] | Any:
        ...
    
    @property
    def d6_loose(self): # -> floating[Any] | Any:
        ...
    
    @property
    def d8_loose(self): # -> floating[Any] | Any:
        ...
    
    @property
    def d10_loose(self): # -> floating[Any] | Any:
        ...
    
    def pade3(self): # -> tuple[Any, Any]:
        ...
    
    def pade5(self): # -> tuple[Any, Any]:
        ...
    
    def pade7(self): # -> tuple[Any, Any]:
        ...
    
    def pade9(self): # -> tuple[Any, Any]:
        ...
    
    def pade13_scaled(self, s): # -> tuple[Any, Any]:
        ...
    


def expm(A): # -> ndarray[Any, dtype[Any]] | NDArray[Any] | csc_array | Any | NDArray[floating[_64Bit]] | _NotImplementedType:
    """
    Compute the matrix exponential using Pade approximation.

    Parameters
    ----------
    A : (M,M) array_like or sparse array
        2D Array or Matrix (sparse or dense) to be exponentiated

    Returns
    -------
    expA : (M,M) ndarray
        Matrix exponential of `A`

    Notes
    -----
    This is algorithm (6.1) which is a simplification of algorithm (5.1).

    .. versionadded:: 0.12.0

    References
    ----------
    .. [1] Awad H. Al-Mohy and Nicholas J. Higham (2009)
           "A New Scaling and Squaring Algorithm for the Matrix Exponential."
           SIAM Journal on Matrix Analysis and Applications.
           31 (3). pp. 970-989. ISSN 1095-7162

    Examples
    --------
    >>> from scipy.sparse import csc_array
    >>> from scipy.sparse.linalg import expm
    >>> A = csc_array([[1, 0, 0], [0, 2, 0], [0, 0, 3]])
    >>> A.toarray()
    array([[1, 0, 0],
           [0, 2, 0],
           [0, 0, 3]], dtype=int64)
    >>> Aexp = expm(A)
    >>> Aexp
    <Compressed Sparse Column sparse array of dtype 'float64'
        with 3 stored elements and shape (3, 3)>
    >>> Aexp.toarray()
    array([[  2.71828183,   0.        ,   0.        ],
           [  0.        ,   7.3890561 ,   0.        ],
           [  0.        ,   0.        ,  20.08553692]])
    """
    ...

def matrix_power(A, power): # -> coo_array | coo_matrix | dia_array | Any | dia_matrix | _NotImplementedType:
    """
    Raise a square matrix to the integer power, `power`.

    For non-negative integers, ``A**power`` is computed using repeated
    matrix multiplications. Negative integers are not supported. 

    Parameters
    ----------
    A : (M, M) square sparse array or matrix
        sparse array that will be raised to power `power`
    power : int
        Exponent used to raise sparse array `A`

    Returns
    -------
    A**power : (M, M) sparse array or matrix
        The output matrix will be the same shape as A, and will preserve
        the class of A, but the format of the output may be changed.
    
    Notes
    -----
    This uses a recursive implementation of the matrix power. For computing
    the matrix power using a reasonably large `power`, this may be less efficient
    than computing the product directly, using A @ A @ ... @ A.
    This is contingent upon the number of nonzero entries in the matrix. 

    .. versionadded:: 1.12.0

    Examples
    --------
    >>> from scipy import sparse
    >>> A = sparse.csc_array([[0,1,0],[1,0,1],[0,1,0]])
    >>> A.todense()
    array([[0, 1, 0],
           [1, 0, 1],
           [0, 1, 0]])
    >>> (A @ A).todense()
    array([[1, 0, 1],
           [0, 2, 0],
           [1, 0, 1]])
    >>> A2 = sparse.linalg.matrix_power(A, 2)
    >>> A2.todense()
    array([[1, 0, 1],
           [0, 2, 0],
           [1, 0, 1]])
    >>> A4 = sparse.linalg.matrix_power(A, 4)
    >>> A4.todense()
    array([[2, 0, 2],
           [0, 4, 0],
           [2, 0, 2]])

    """
    ...

