"""
This type stub file was generated by pyright.
"""

__all__ = ['MetaData', 'loadarff', 'ArffError', 'ParseArffError']
r_meta = ...
r_comment = ...
r_empty = ...
r_headerline = ...
r_datameta = ...
r_relation = ...
r_attribute = ...
r_nominal = ...
r_date = ...
r_comattrval = ...
r_wcomattrval = ...
class ArffError(OSError):
    ...


class ParseArffError(ArffError):
    ...


class Attribute:
    type_name = ...
    def __init__(self, name) -> None:
        ...
    
    @classmethod
    def parse_attribute(cls, name, attr_string): # -> None:
        """
        Parse the attribute line if it knows how. Returns the parsed
        attribute, or None.
        """
        ...
    
    def parse_data(self, data_str): # -> None:
        """
        Parse a value of this type.
        """
        ...
    
    def __str__(self) -> str:
        """
        Parse a value of this type.
        """
        ...
    


class NominalAttribute(Attribute):
    type_name = ...
    def __init__(self, name, values) -> None:
        ...
    
    @classmethod
    def parse_attribute(cls, name, attr_string): # -> Self | None:
        """
        Parse the attribute line if it knows how. Returns the parsed
        attribute, or None.

        For nominal attributes, the attribute string would be like '{<attr_1>,
         <attr2>, <attr_3>}'.
        """
        ...
    
    def parse_data(self, data_str): # -> Literal['?']:
        """
        Parse a value of this type.
        """
        ...
    
    def __str__(self) -> str:
        ...
    


class NumericAttribute(Attribute):
    def __init__(self, name) -> None:
        ...
    
    @classmethod
    def parse_attribute(cls, name, attr_string): # -> Self | None:
        """
        Parse the attribute line if it knows how. Returns the parsed
        attribute, or None.

        For numeric attributes, the attribute string would be like
        'numeric' or 'int' or 'real'.
        """
        ...
    
    def parse_data(self, data_str): # -> float:
        """
        Parse a value of this type.

        Parameters
        ----------
        data_str : str
           string to convert

        Returns
        -------
        f : float
           where float can be nan

        Examples
        --------
        >>> from scipy.io.arff._arffread import NumericAttribute
        >>> atr = NumericAttribute('atr')
        >>> atr.parse_data('1')
        1.0
        >>> atr.parse_data('1\\n')
        1.0
        >>> atr.parse_data('?\\n')
        nan
        """
        ...
    


class StringAttribute(Attribute):
    def __init__(self, name) -> None:
        ...
    
    @classmethod
    def parse_attribute(cls, name, attr_string): # -> Self | None:
        """
        Parse the attribute line if it knows how. Returns the parsed
        attribute, or None.

        For string attributes, the attribute string would be like
        'string'.
        """
        ...
    


class DateAttribute(Attribute):
    def __init__(self, name, date_format, datetime_unit) -> None:
        ...
    
    @classmethod
    def parse_attribute(cls, name, attr_string): # -> Self | None:
        """
        Parse the attribute line if it knows how. Returns the parsed
        attribute, or None.

        For date attributes, the attribute string would be like
        'date <format>'.
        """
        ...
    
    def parse_data(self, data_str): # -> datetime64 | Any:
        """
        Parse a value of this type.
        """
        ...
    
    def __str__(self) -> str:
        ...
    


class RelationalAttribute(Attribute):
    def __init__(self, name) -> None:
        ...
    
    @classmethod
    def parse_attribute(cls, name, attr_string): # -> Self | None:
        """
        Parse the attribute line if it knows how. Returns the parsed
        attribute, or None.

        For date attributes, the attribute string would be like
        'date <format>'.
        """
        ...
    
    def parse_data(self, data_str): # -> NDArray[Any]:
        ...
    
    def __str__(self) -> str:
        ...
    


def to_attribute(name, attr_string): # -> NominalAttribute | NumericAttribute | DateAttribute | StringAttribute | RelationalAttribute:
    ...

def csv_sniffer_has_bug_last_field(): # -> bool | Any:
    """
    Checks if the bug https://bugs.python.org/issue30157 is unpatched.
    """
    ...

def workaround_csv_sniffer_bug_last_field(sniff_line, dialect, delimiters): # -> None:
    """
    Workaround for the bug https://bugs.python.org/issue30157 if is unpatched.
    """
    ...

def split_data_line(line, dialect=...): # -> tuple[list[str], type[Dialect] | Any]:
    ...

def tokenize_attribute(iterable, attribute): # -> tuple[NominalAttribute | NumericAttribute | DateAttribute | StringAttribute | RelationalAttribute, Any]:
    """Parse a raw string in header (e.g., starts by @attribute).

    Given a raw string attribute, try to get the name and type of the
    attribute. Constraints:

    * The first line must start with @attribute (case insensitive, and
      space like characters before @attribute are allowed)
    * Works also if the attribute is spread on multilines.
    * Works if empty lines or comments are in between

    Parameters
    ----------
    attribute : str
       the attribute string.

    Returns
    -------
    name : str
       name of the attribute
    value : str
       value of the attribute
    next : str
       next line to be parsed

    Examples
    --------
    If attribute is a string defined in python as r"floupi real", will
    return floupi as name, and real as value.

    >>> from scipy.io.arff._arffread import tokenize_attribute
    >>> iterable = iter([0] * 10) # dummy iterator
    >>> tokenize_attribute(iterable, r"@attribute floupi real")
    ('floupi', 'real', 0)

    If attribute is r"'floupi 2' real", will return 'floupi 2' as name,
    and real as value.

    >>> tokenize_attribute(iterable, r"  @attribute 'floupi 2' real   ")
    ('floupi 2', 'real', 0)

    """
    ...

def tokenize_single_comma(val): # -> tuple[str | Any, str | Any]:
    ...

def tokenize_single_wcomma(val): # -> tuple[str | Any, str | Any]:
    ...

def read_relational_attribute(ofile, relational_attribute, i):
    """Read the nested attributes of a relational attribute"""
    ...

def read_header(ofile): # -> tuple[str | Any | None, list[Any]]:
    """Read the header of the iterable ofile."""
    ...

class MetaData:
    """Small container to keep useful information on a ARFF dataset.

    Knows about attributes names and types.

    Examples
    --------
    ::

        data, meta = loadarff('iris.arff')
        # This will print the attributes names of the iris.arff dataset
        for i in meta:
            print(i)
        # This works too
        meta.names()
        # Getting attribute type
        types = meta.types()

    Methods
    -------
    names
    types

    Notes
    -----
    Also maintains the list of attributes in order, i.e., doing for i in
    meta, where meta is an instance of MetaData, will return the
    different attribute names in the order they were defined.
    """
    def __init__(self, rel, attr) -> None:
        ...
    
    def __repr__(self): # -> str:
        ...
    
    def __iter__(self): # -> Iterator[Any]:
        ...
    
    def __getitem__(self, key): # -> tuple[Any, Any]:
        ...
    
    def names(self): # -> list[Any]:
        """Return the list of attribute names.

        Returns
        -------
        attrnames : list of str
            The attribute names.
        """
        ...
    
    def types(self): # -> list[Any]:
        """Return the list of attribute types.

        Returns
        -------
        attr_types : list of str
            The attribute types.
        """
        ...
    


def loadarff(f): # -> tuple[NDArray[Any], MetaData]:
    """
    Read an arff file.

    The data is returned as a record array, which can be accessed much like
    a dictionary of NumPy arrays. For example, if one of the attributes is
    called 'pressure', then its first 10 data points can be accessed from the
    ``data`` record array like so: ``data['pressure'][0:10]``


    Parameters
    ----------
    f : file-like or str
       File-like object to read from, or filename to open.

    Returns
    -------
    data : record array
       The data of the arff file, accessible by attribute names.
    meta : `MetaData`
       Contains information about the arff file such as name and
       type of attributes, the relation (name of the dataset), etc.

    Raises
    ------
    ParseArffError
        This is raised if the given file is not ARFF-formatted.
    NotImplementedError
        The ARFF file has an attribute which is not supported yet.

    Notes
    -----

    This function should be able to read most arff files. Not
    implemented functionality include:

    * date type attributes
    * string type attributes

    It can read files with numeric and nominal attributes. It cannot read
    files with sparse data ({} in the file). However, this function can
    read files with missing data (? in the file), representing the data
    points as NaNs.

    Examples
    --------
    >>> from scipy.io import arff
    >>> from io import StringIO
    >>> content = \"\"\"
    ... @relation foo
    ... @attribute width  numeric
    ... @attribute height numeric
    ... @attribute color  {red,green,blue,yellow,black}
    ... @data
    ... 5.0,3.25,blue
    ... 4.5,3.75,green
    ... 3.0,4.00,red
    ... \"\"\"
    >>> f = StringIO(content)
    >>> data, meta = arff.loadarff(f)
    >>> data
    array([(5.0, 3.25, 'blue'), (4.5, 3.75, 'green'), (3.0, 4.0, 'red')],
          dtype=[('width', '<f8'), ('height', '<f8'), ('color', '|S6')])
    >>> meta
    Dataset: foo
    \twidth's type is numeric
    \theight's type is numeric
    \tcolor's type is nominal, range is ('red', 'green', 'blue', 'yellow', 'black')

    """
    ...

