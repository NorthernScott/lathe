"""
This type stub file was generated by pyright.
"""

from ..common._aliases import UniqueAllResult, UniqueCountsResult, UniqueInverseResult
from typing import List, Optional, Sequence, TYPE_CHECKING, Tuple, Union
from ..common._typing import Device
from torch import dtype as Dtype

if TYPE_CHECKING:
    array = ...
_int_dtypes = ...
_array_api_dtypes = ...
_promotion_table = ...
def result_type(*arrays_and_dtypes: Union[array, Dtype]) -> Dtype:
    ...

def can_cast(from_: Union[Dtype, array], to: Dtype, /) -> bool:
    ...

bitwise_invert = ...
newaxis = ...
conj = ...
add = ...
atan2 = ...
bitwise_and = ...
bitwise_left_shift = ...
bitwise_or = ...
bitwise_right_shift = ...
bitwise_xor = ...
copysign = ...
divide = ...
equal = ...
floor_divide = ...
greater = ...
greater_equal = ...
hypot = ...
less = ...
less_equal = ...
logaddexp = ...
maximum = ...
minimum = ...
multiply = ...
not_equal = ...
pow = ...
remainder = ...
subtract = ...
def max(x: array, /, *, axis: Optional[Union[int, Tuple[int, ...]]] = ..., keepdims: bool = ...) -> array:
    ...

def min(x: array, /, *, axis: Optional[Union[int, Tuple[int, ...]]] = ..., keepdims: bool = ...) -> array:
    ...

clip = ...
unstack = ...
cumulative_sum = ...
def sort(x: array, /, *, axis: int = ..., descending: bool = ..., stable: bool = ..., **kwargs) -> array:
    ...

def prod(x: array, /, *, axis: Optional[Union[int, Tuple[int, ...]]] = ..., dtype: Optional[Dtype] = ..., keepdims: bool = ..., **kwargs) -> array:
    ...

def sum(x: array, /, *, axis: Optional[Union[int, Tuple[int, ...]]] = ..., dtype: Optional[Dtype] = ..., keepdims: bool = ..., **kwargs) -> array:
    ...

def any(x: array, /, *, axis: Optional[Union[int, Tuple[int, ...]]] = ..., keepdims: bool = ..., **kwargs) -> array:
    ...

def all(x: array, /, *, axis: Optional[Union[int, Tuple[int, ...]]] = ..., keepdims: bool = ..., **kwargs) -> array:
    ...

def mean(x: array, /, *, axis: Optional[Union[int, Tuple[int, ...]]] = ..., keepdims: bool = ..., **kwargs) -> array:
    ...

def std(x: array, /, *, axis: Optional[Union[int, Tuple[int, ...]]] = ..., correction: Union[int, float] = ..., keepdims: bool = ..., **kwargs) -> array:
    ...

def var(x: array, /, *, axis: Optional[Union[int, Tuple[int, ...]]] = ..., correction: Union[int, float] = ..., keepdims: bool = ..., **kwargs) -> array:
    ...

def concat(arrays: Union[Tuple[array, ...], List[array]], /, *, axis: Optional[int] = ..., **kwargs) -> array:
    ...

def squeeze(x: array, /, axis: Union[int, Tuple[int, ...]]) -> array:
    ...

def broadcast_to(x: array, /, shape: Tuple[int, ...], **kwargs) -> array:
    ...

def permute_dims(x: array, /, axes: Tuple[int, ...]) -> array:
    ...

def flip(x: array, /, *, axis: Optional[Union[int, Tuple[int, ...]]] = ..., **kwargs) -> array:
    ...

def roll(x: array, /, shift: Union[int, Tuple[int, ...]], *, axis: Optional[Union[int, Tuple[int, ...]]] = ..., **kwargs) -> array:
    ...

def nonzero(x: array, /, **kwargs) -> Tuple[array, ...]:
    ...

def where(condition: array, x1: array, x2: array, /) -> array:
    ...

def reshape(x: array, /, shape: Tuple[int, ...], copy: Optional[bool] = ..., **kwargs) -> array:
    ...

def arange(start: Union[int, float], /, stop: Optional[Union[int, float]] = ..., step: Union[int, float] = ..., *, dtype: Optional[Dtype] = ..., device: Optional[Device] = ..., **kwargs) -> array:
    ...

def eye(n_rows: int, n_cols: Optional[int] = ..., /, *, k: int = ..., dtype: Optional[Dtype] = ..., device: Optional[Device] = ..., **kwargs) -> array:
    ...

def linspace(start: Union[int, float], stop: Union[int, float], /, num: int, *, dtype: Optional[Dtype] = ..., device: Optional[Device] = ..., endpoint: bool = ..., **kwargs) -> array:
    ...

def full(shape: Union[int, Tuple[int, ...]], fill_value: Union[bool, int, float, complex], *, dtype: Optional[Dtype] = ..., device: Optional[Device] = ..., **kwargs) -> array:
    ...

def ones(shape: Union[int, Tuple[int, ...]], *, dtype: Optional[Dtype] = ..., device: Optional[Device] = ..., **kwargs) -> array:
    ...

def zeros(shape: Union[int, Tuple[int, ...]], *, dtype: Optional[Dtype] = ..., device: Optional[Device] = ..., **kwargs) -> array:
    ...

def empty(shape: Union[int, Tuple[int, ...]], *, dtype: Optional[Dtype] = ..., device: Optional[Device] = ..., **kwargs) -> array:
    ...

def tril(x: array, /, *, k: int = ...) -> array:
    ...

def triu(x: array, /, *, k: int = ...) -> array:
    ...

def expand_dims(x: array, /, *, axis: int = ...) -> array:
    ...

def astype(x: array, dtype: Dtype, /, *, copy: bool = ...) -> array:
    ...

def broadcast_arrays(*arrays: array) -> List[array]:
    ...

def unique_all(x: array) -> UniqueAllResult:
    ...

def unique_counts(x: array) -> UniqueCountsResult:
    ...

def unique_inverse(x: array) -> UniqueInverseResult:
    ...

def unique_values(x: array) -> array:
    ...

def matmul(x1: array, x2: array, /, **kwargs) -> array:
    ...

matrix_transpose = ...
_vecdot = ...
def vecdot(x1: array, x2: array, /, *, axis: int = ...) -> array:
    ...

def tensordot(x1: array, x2: array, /, *, axes: Union[int, Tuple[Sequence[int], Sequence[int]]] = ..., **kwargs) -> array:
    ...

def isdtype(dtype: Dtype, kind: Union[Dtype, str, Tuple[Union[Dtype, str], ...]], *, _tuple=...) -> bool:
    """
    Returns a boolean indicating whether a provided dtype is of a specified data type ``kind``.

    Note that outside of this function, this compat library does not yet fully
    support complex numbers.

    See
    https://data-apis.org/array-api/latest/API_specification/generated/array_api.isdtype.html
    for more details
    """
    ...

def take(x: array, indices: array, /, *, axis: Optional[int] = ..., **kwargs) -> array:
    ...

def sign(x: array, /) -> array:
    ...

__all__ = ['__array_namespace_info__', 'result_type', 'can_cast', 'permute_dims', 'bitwise_invert', 'newaxis', 'conj', 'add', 'atan2', 'bitwise_and', 'bitwise_left_shift', 'bitwise_or', 'bitwise_right_shift', 'bitwise_xor', 'copysign', 'divide', 'equal', 'floor_divide', 'greater', 'greater_equal', 'hypot', 'less', 'less_equal', 'logaddexp', 'maximum', 'minimum', 'multiply', 'not_equal', 'pow', 'remainder', 'subtract', 'max', 'min', 'clip', 'unstack', 'cumulative_sum', 'sort', 'prod', 'sum', 'any', 'all', 'mean', 'std', 'var', 'concat', 'squeeze', 'broadcast_to', 'flip', 'roll', 'nonzero', 'where', 'reshape', 'arange', 'eye', 'linspace', 'full', 'ones', 'zeros', 'empty', 'tril', 'triu', 'expand_dims', 'astype', 'broadcast_arrays', 'UniqueAllResult', 'UniqueCountsResult', 'UniqueInverseResult', 'unique_all', 'unique_counts', 'unique_inverse', 'unique_values', 'matmul', 'matrix_transpose', 'vecdot', 'tensordot', 'isdtype', 'take', 'sign']
_all_ignore = ...
