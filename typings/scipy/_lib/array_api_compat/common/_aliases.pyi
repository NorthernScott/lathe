"""
This type stub file was generated by pyright.
"""

from typing import NamedTuple, Optional, Sequence, TYPE_CHECKING, Tuple, Union
from ._typing import Device, Dtype, ndarray

"""
These are functions that are just aliases of existing functions in NumPy.
"""
if TYPE_CHECKING:
    ...
def arange(start: Union[int, float], /, stop: Optional[Union[int, float]] = ..., step: Union[int, float] = ..., *, xp, dtype: Optional[Dtype] = ..., device: Optional[Device] = ..., **kwargs) -> ndarray:
    ...

def empty(shape: Union[int, Tuple[int, ...]], xp, *, dtype: Optional[Dtype] = ..., device: Optional[Device] = ..., **kwargs) -> ndarray:
    ...

def empty_like(x: ndarray, /, xp, *, dtype: Optional[Dtype] = ..., device: Optional[Device] = ..., **kwargs) -> ndarray:
    ...

def eye(n_rows: int, n_cols: Optional[int] = ..., /, *, xp, k: int = ..., dtype: Optional[Dtype] = ..., device: Optional[Device] = ..., **kwargs) -> ndarray:
    ...

def full(shape: Union[int, Tuple[int, ...]], fill_value: Union[int, float], xp, *, dtype: Optional[Dtype] = ..., device: Optional[Device] = ..., **kwargs) -> ndarray:
    ...

def full_like(x: ndarray, /, fill_value: Union[int, float], *, xp, dtype: Optional[Dtype] = ..., device: Optional[Device] = ..., **kwargs) -> ndarray:
    ...

def linspace(start: Union[int, float], stop: Union[int, float], /, num: int, *, xp, dtype: Optional[Dtype] = ..., device: Optional[Device] = ..., endpoint: bool = ..., **kwargs) -> ndarray:
    ...

def ones(shape: Union[int, Tuple[int, ...]], xp, *, dtype: Optional[Dtype] = ..., device: Optional[Device] = ..., **kwargs) -> ndarray:
    ...

def ones_like(x: ndarray, /, xp, *, dtype: Optional[Dtype] = ..., device: Optional[Device] = ..., **kwargs) -> ndarray:
    ...

def zeros(shape: Union[int, Tuple[int, ...]], xp, *, dtype: Optional[Dtype] = ..., device: Optional[Device] = ..., **kwargs) -> ndarray:
    ...

def zeros_like(x: ndarray, /, xp, *, dtype: Optional[Dtype] = ..., device: Optional[Device] = ..., **kwargs) -> ndarray:
    ...

class UniqueAllResult(NamedTuple):
    values: ndarray
    indices: ndarray
    inverse_indices: ndarray
    counts: ndarray
    ...


class UniqueCountsResult(NamedTuple):
    values: ndarray
    counts: ndarray
    ...


class UniqueInverseResult(NamedTuple):
    values: ndarray
    inverse_indices: ndarray
    ...


def unique_all(x: ndarray, /, xp) -> UniqueAllResult:
    ...

def unique_counts(x: ndarray, /, xp) -> UniqueCountsResult:
    ...

def unique_inverse(x: ndarray, /, xp) -> UniqueInverseResult:
    ...

def unique_values(x: ndarray, /, xp) -> ndarray:
    ...

def astype(x: ndarray, dtype: Dtype, /, *, copy: bool = ...) -> ndarray:
    ...

def std(x: ndarray, /, xp, *, axis: Optional[Union[int, Tuple[int, ...]]] = ..., correction: Union[int, float] = ..., keepdims: bool = ..., **kwargs) -> ndarray:
    ...

def var(x: ndarray, /, xp, *, axis: Optional[Union[int, Tuple[int, ...]]] = ..., correction: Union[int, float] = ..., keepdims: bool = ..., **kwargs) -> ndarray:
    ...

def cumulative_sum(x: ndarray, /, xp, *, axis: Optional[int] = ..., dtype: Optional[Dtype] = ..., include_initial: bool = ..., **kwargs) -> ndarray:
    ...

def clip(x: ndarray, /, min: Optional[Union[int, float, ndarray]] = ..., max: Optional[Union[int, float, ndarray]] = ..., *, xp, out: Optional[ndarray] = ...) -> ndarray:
    ...

def permute_dims(x: ndarray, /, axes: Tuple[int, ...], xp) -> ndarray:
    ...

def reshape(x: ndarray, /, shape: Tuple[int, ...], xp, copy: Optional[bool] = ..., **kwargs) -> ndarray:
    ...

def argsort(x: ndarray, /, xp, *, axis: int = ..., descending: bool = ..., stable: bool = ..., **kwargs) -> ndarray:
    ...

def sort(x: ndarray, /, xp, *, axis: int = ..., descending: bool = ..., stable: bool = ..., **kwargs) -> ndarray:
    ...

def nonzero(x: ndarray, /, xp, **kwargs) -> Tuple[ndarray, ...]:
    ...

def ceil(x: ndarray, /, xp, **kwargs) -> ndarray:
    ...

def floor(x: ndarray, /, xp, **kwargs) -> ndarray:
    ...

def trunc(x: ndarray, /, xp, **kwargs) -> ndarray:
    ...

def matmul(x1: ndarray, x2: ndarray, /, xp, **kwargs) -> ndarray:
    ...

def matrix_transpose(x: ndarray, /, xp) -> ndarray:
    ...

def tensordot(x1: ndarray, x2: ndarray, /, xp, *, axes: Union[int, Tuple[Sequence[int], Sequence[int]]] = ..., **kwargs) -> ndarray:
    ...

def vecdot(x1: ndarray, x2: ndarray, /, xp, *, axis: int = ...) -> ndarray:
    ...

def isdtype(dtype: Dtype, kind: Union[Dtype, str, Tuple[Union[Dtype, str], ...]], xp, *, _tuple=...) -> bool:
    """
    Returns a boolean indicating whether a provided dtype is of a specified data type ``kind``.

    Note that outside of this function, this compat library does not yet fully
    support complex numbers.

    See
    https://data-apis.org/array-api/latest/API_specification/generated/array_api.isdtype.html
    for more details
    """
    ...

def unstack(x: ndarray, /, xp, *, axis: int = ...) -> Tuple[ndarray, ...]:
    ...

def sign(x: ndarray, /, xp, **kwargs) -> ndarray:
    ...

__all__ = ['arange', 'empty', 'empty_like', 'eye', 'full', 'full_like', 'linspace', 'ones', 'ones_like', 'zeros', 'zeros_like', 'UniqueAllResult', 'UniqueCountsResult', 'UniqueInverseResult', 'unique_all', 'unique_counts', 'unique_inverse', 'unique_values', 'astype', 'std', 'var', 'cumulative_sum', 'clip', 'permute_dims', 'reshape', 'argsort', 'sort', 'nonzero', 'ceil', 'floor', 'trunc', 'matmul', 'matrix_transpose', 'tensordot', 'vecdot', 'isdtype', 'unstack', 'sign']
