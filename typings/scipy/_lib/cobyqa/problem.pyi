"""
This type stub file was generated by pyright.
"""

class ObjectiveFunction:
    """
    Real-valued objective function.
    """
    def __init__(self, fun, verbose, debug, *args) -> None:
        """
        Initialize the objective function.

        Parameters
        ----------
        fun : {callable, None}
            Function to evaluate, or None.

                ``fun(x, *args) -> float``

            where ``x`` is an array with shape (n,) and `args` is a tuple.
        verbose : bool
            Whether to print the function evaluations.
        debug : bool
            Whether to make debugging tests during the execution.
        *args : tuple
            Additional arguments to be passed to the function.
        """
        ...
    
    def __call__(self, x): # -> float:
        """
        Evaluate the objective function.

        Parameters
        ----------
        x : array_like, shape (n,)
            Point at which the objective function is evaluated.

        Returns
        -------
        float
            Function value at `x`.
        """
        ...
    
    @property
    def n_eval(self): # -> int:
        """
        Number of function evaluations.

        Returns
        -------
        int
            Number of function evaluations.
        """
        ...
    
    @property
    def name(self): # -> str:
        """
        Name of the objective function.

        Returns
        -------
        str
            Name of the objective function.
        """
        ...
    


class BoundConstraints:
    """
    Bound constraints ``xl <= x <= xu``.
    """
    def __init__(self, bounds) -> None:
        """
        Initialize the bound constraints.

        Parameters
        ----------
        bounds : scipy.optimize.Bounds
            Bound constraints.
        """
        ...
    
    @property
    def xl(self): # -> NDArray[Any]:
        """
        Lower bound.

        Returns
        -------
        `numpy.ndarray`, shape (n,)
            Lower bound.
        """
        ...
    
    @property
    def xu(self): # -> NDArray[Any]:
        """
        Upper bound.

        Returns
        -------
        `numpy.ndarray`, shape (n,)
            Upper bound.
        """
        ...
    
    def maxcv(self, x): # -> NDArray[Any]:
        """
        Evaluate the maximum constraint violation.

        Parameters
        ----------
        x : array_like, shape (n,)
            Point at which the maximum constraint violation is evaluated.

        Returns
        -------
        float
            Maximum constraint violation at `x`.
        """
        ...
    
    def violation(self, x): # -> NDArray[Any]:
        ...
    
    def project(self, x):
        """
        Project a point onto the feasible set.

        Parameters
        ----------
        x : array_like, shape (n,)
            Point to be projected.

        Returns
        -------
        `numpy.ndarray`, shape (n,)
            Projection of `x` onto the feasible set.
        """
        ...
    


class LinearConstraints:
    """
    Linear constraints ``a_ub @ x <= b_ub`` and ``a_eq @ x == b_eq``.
    """
    def __init__(self, constraints, n, debug) -> None:
        """
        Initialize the linear constraints.

        Parameters
        ----------
        constraints : list of LinearConstraint
            Linear constraints.
        n : int
            Number of variables.
        debug : bool
            Whether to make debugging tests during the execution.
        """
        ...
    
    @property
    def a_ub(self): # -> NDArray[float64]:
        """
        Left-hand side matrix of the linear inequality constraints.

        Returns
        -------
        `numpy.ndarray`, shape (m, n)
            Left-hand side matrix of the linear inequality constraints.
        """
        ...
    
    @property
    def b_ub(self): # -> NDArray[float64]:
        """
        Right-hand side vector of the linear inequality constraints.

        Returns
        -------
        `numpy.ndarray`, shape (m, n)
            Right-hand side vector of the linear inequality constraints.
        """
        ...
    
    @property
    def a_eq(self): # -> NDArray[float64]:
        """
        Left-hand side matrix of the linear equality constraints.

        Returns
        -------
        `numpy.ndarray`, shape (m, n)
            Left-hand side matrix of the linear equality constraints.
        """
        ...
    
    @property
    def b_eq(self): # -> NDArray[float64]:
        """
        Right-hand side vector of the linear equality constraints.

        Returns
        -------
        `numpy.ndarray`, shape (m, n)
            Right-hand side vector of the linear equality constraints.
        """
        ...
    
    @property
    def m_ub(self): # -> int:
        """
        Number of linear inequality constraints.

        Returns
        -------
        int
            Number of linear inequality constraints.
        """
        ...
    
    @property
    def m_eq(self): # -> int:
        """
        Number of linear equality constraints.

        Returns
        -------
        int
            Number of linear equality constraints.
        """
        ...
    
    def maxcv(self, x): # -> Any:
        """
        Evaluate the maximum constraint violation.

        Parameters
        ----------
        x : array_like, shape (n,)
            Point at which the maximum constraint violation is evaluated.

        Returns
        -------
        float
            Maximum constraint violation at `x`.
        """
        ...
    
    def violation(self, x): # -> NDArray[Any]:
        ...
    


class NonlinearConstraints:
    """
    Nonlinear constraints ``c_ub(x) <= 0`` and ``c_eq(x) == b_eq``.
    """
    def __init__(self, constraints, verbose, debug) -> None:
        """
        Initialize the nonlinear constraints.

        Parameters
        ----------
        constraints : list
            Nonlinear constraints.
        verbose : bool
            Whether to print the function evaluations.
        debug : bool
            Whether to make debugging tests during the execution.
        """
        ...
    
    def __call__(self, x): # -> tuple[NDArray[Any], NDArray[Any]]:
        """
        Calculates the residual (slack) for the constraints.

        Parameters
        ----------
        x : array_like, shape (n,)
            Point at which the constraints are evaluated.

        Returns
        -------
        `numpy.ndarray`, shape (m_nonlinear_ub,)
            Nonlinear inequality constraint slack values.
        `numpy.ndarray`, shape (m_nonlinear_eq,)
            Nonlinear equality constraint slack values.
        """
        ...
    
    @property
    def m_ub(self): # -> int:
        """
        Number of nonlinear inequality constraints.

        Returns
        -------
        int
            Number of nonlinear inequality constraints.

        Raises
        ------
        ValueError
            If the number of nonlinear inequality constraints is unknown.
        """
        ...
    
    @property
    def m_eq(self): # -> int:
        """
        Number of nonlinear equality constraints.

        Returns
        -------
        int
            Number of nonlinear equality constraints.

        Raises
        ------
        ValueError
            If the number of nonlinear equality constraints is unknown.
        """
        ...
    
    @property
    def n_eval(self): # -> Literal[0]:
        """
        Number of function evaluations.

        Returns
        -------
        int
            Number of function evaluations.
        """
        ...
    
    def maxcv(self, x, cub_val=..., ceq_val=...):
        """
        Evaluate the maximum constraint violation.

        Parameters
        ----------
        x : array_like, shape (n,)
            Point at which the maximum constraint violation is evaluated.
        cub_val : array_like, shape (m_nonlinear_ub,), optional
            Values of the nonlinear inequality constraints. If not provided,
            the nonlinear inequality constraints are evaluated at `x`.
        ceq_val : array_like, shape (m_nonlinear_eq,), optional
            Values of the nonlinear equality constraints. If not provided,
            the nonlinear equality constraints are evaluated at `x`.

        Returns
        -------
        float
            Maximum constraint violation at `x`.
        """
        ...
    
    def violation(self, x, cub_val=..., ceq_val=...): # -> NDArray[Any]:
        ...
    


class Problem:
    """
    Optimization problem.
    """
    def __init__(self, obj, x0, bounds, linear, nonlinear, callback, feasibility_tol, scale, store_history, history_size, filter_size, debug) -> None:
        """
        Initialize the nonlinear problem.

        The problem is preprocessed to remove all the variables that are fixed
        by the bound constraints.

        Parameters
        ----------
        obj : ObjectiveFunction
            Objective function.
        x0 : array_like, shape (n,)
            Initial guess.
        bounds : BoundConstraints
            Bound constraints.
        linear : LinearConstraints
            Linear constraints.
        nonlinear : NonlinearConstraints
            Nonlinear constraints.
        callback : {callable, None}
            Callback function.
        feasibility_tol : float
            Tolerance on the constraint violation.
        scale : bool
            Whether to scale the problem according to the bounds.
        store_history : bool
            Whether to store the function evaluations.
        history_size : int
            Maximum number of function evaluations to store.
        filter_size : int
            Maximum number of points in the filter.
        debug : bool
            Whether to make debugging tests during the execution.
        """
        ...
    
    def __call__(self, x, penalty=...): # -> tuple[float, NDArray[Any], NDArray[Any]]:
        """
        Evaluate the objective and nonlinear constraint functions.

        Parameters
        ----------
        x : array_like, shape (n,)
            Point at which the functions are evaluated.
        penalty : float, optional
            Penalty parameter used to select the point in the filter to forward
            to the callback function.

        Returns
        -------
        float
            Objective function value.
        `numpy.ndarray`, shape (m_nonlinear_ub,)
            Nonlinear inequality constraint function values.
        `numpy.ndarray`, shape (m_nonlinear_eq,)
            Nonlinear equality constraint function values.

        Raises
        ------
        `cobyqa.utils.CallbackSuccess`
            If the callback function raises a ``StopIteration``.
        """
        ...
    
    @property
    def n(self):
        """
        Number of variables.

        Returns
        -------
        int
            Number of variables.
        """
        ...
    
    @property
    def n_orig(self): # -> Any:
        """
        Number of variables in the original problem (with fixed variables).

        Returns
        -------
        int
            Number of variables in the original problem (with fixed variables).
        """
        ...
    
    @property
    def x0(self):
        """
        Initial guess.

        Returns
        -------
        `numpy.ndarray`, shape (n,)
            Initial guess.
        """
        ...
    
    @property
    def n_eval(self): # -> int:
        """
        Number of function evaluations.

        Returns
        -------
        int
            Number of function evaluations.
        """
        ...
    
    @property
    def fun_name(self): # -> str:
        """
        Name of the objective function.

        Returns
        -------
        str
            Name of the objective function.
        """
        ...
    
    @property
    def bounds(self): # -> BoundConstraints:
        """
        Bound constraints.

        Returns
        -------
        BoundConstraints
            Bound constraints.
        """
        ...
    
    @property
    def linear(self): # -> LinearConstraints | Any:
        """
        Linear constraints.

        Returns
        -------
        LinearConstraints
            Linear constraints.
        """
        ...
    
    @property
    def m_bounds(self): # -> int:
        """
        Number of bound constraints.

        Returns
        -------
        int
            Number of bound constraints.
        """
        ...
    
    @property
    def m_linear_ub(self): # -> int:
        """
        Number of linear inequality constraints.

        Returns
        -------
        int
            Number of linear inequality constraints.
        """
        ...
    
    @property
    def m_linear_eq(self): # -> int:
        """
        Number of linear equality constraints.

        Returns
        -------
        int
            Number of linear equality constraints.
        """
        ...
    
    @property
    def m_nonlinear_ub(self): # -> int:
        """
        Number of nonlinear inequality constraints.

        Returns
        -------
        int
            Number of nonlinear inequality constraints.

        Raises
        ------
        ValueError
            If the number of nonlinear inequality constraints is not known.
        """
        ...
    
    @property
    def m_nonlinear_eq(self): # -> int:
        """
        Number of nonlinear equality constraints.

        Returns
        -------
        int
            Number of nonlinear equality constraints.

        Raises
        ------
        ValueError
            If the number of nonlinear equality constraints is not known.
        """
        ...
    
    @property
    def fun_history(self): # -> NDArray[Any]:
        """
        History of objective function evaluations.

        Returns
        -------
        `numpy.ndarray`, shape (n_eval,)
            History of objective function evaluations.
        """
        ...
    
    @property
    def maxcv_history(self): # -> NDArray[Any]:
        """
        History of maximum constraint violations.

        Returns
        -------
        `numpy.ndarray`, shape (n_eval,)
            History of maximum constraint violations.
        """
        ...
    
    @property
    def type(self): # -> Literal['nonlinearly constrained', 'linearly constrained', 'bound-constrained', 'unconstrained']:
        """
        Type of the problem.

        The problem can be either 'unconstrained', 'bound-constrained',
        'linearly constrained', or 'nonlinearly constrained'.

        Returns
        -------
        str
            Type of the problem.
        """
        ...
    
    @property
    def is_feasibility(self): # -> bool:
        """
        Whether the problem is a feasibility problem.

        Returns
        -------
        bool
            Whether the problem is a feasibility problem.
        """
        ...
    
    def build_x(self, x): # -> NDArray[float64]:
        """
        Build the full vector of variables from the reduced vector.

        Parameters
        ----------
        x : array_like, shape (n,)
            Reduced vector of variables.

        Returns
        -------
        `numpy.ndarray`, shape (n_orig,)
            Full vector of variables.
        """
        ...
    
    def maxcv(self, x, cub_val=..., ceq_val=...): # -> float:
        """
        Evaluate the maximum constraint violation.

        Parameters
        ----------
        x : array_like, shape (n,)
            Point at which the maximum constraint violation is evaluated.
        cub_val : array_like, shape (m_nonlinear_ub,), optional
            Values of the nonlinear inequality constraints. If not provided,
            the nonlinear inequality constraints are evaluated at `x`.
        ceq_val : array_like, shape (m_nonlinear_eq,), optional
            Values of the nonlinear equality constraints. If not provided,
            the nonlinear equality constraints are evaluated at `x`.

        Returns
        -------
        float
            Maximum constraint violation at `x`.
        """
        ...
    
    def violation(self, x, cub_val=..., ceq_val=...): # -> NDArray[Any] | None:
        ...
    
    def best_eval(self, penalty): # -> tuple[Any | ndarray[Any, dtype[Any]], Any, Any]:
        """
        Return the best point in the filter and the corresponding objective and
        nonlinear constraint function evaluations.

        Parameters
        ----------
        penalty : float
            Penalty parameter

        Returns
        -------
        `numpy.ndarray`, shape (n,)
            Best point.
        float
            Corresponding objective function value.
        float
            Corresponding maximum constraint violation.
        """
        ...
    


