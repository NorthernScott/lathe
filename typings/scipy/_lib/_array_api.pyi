"""
This type stub file was generated by pyright.
"""

import numpy.typing as npt
from types import ModuleType
from typing import Any, TypeAlias

"""Utility functions to use Python Array API compatible libraries.

For the context about the Array API see:
https://data-apis.org/array-api/latest/purpose_and_scope.html

The SciPy use case of the Array API is described on the following page:
https://data-apis.org/array-api/latest/use_cases.html#use-case-scipy
"""
__all__ = ['_asarray', 'array_namespace', 'assert_almost_equal', 'assert_array_almost_equal', 'get_xp_devices', 'is_array_api_strict', 'is_complex', 'is_cupy', 'is_jax', 'is_numpy', 'is_torch', 'SCIPY_ARRAY_API', 'SCIPY_DEVICE', 'scipy_namespace_for', 'xp_assert_close', 'xp_assert_equal', 'xp_assert_less', 'xp_copy', 'xp_copysign', 'xp_device', 'xp_moveaxis_to_end', 'xp_ravel', 'xp_real', 'xp_sign', 'xp_size', 'xp_take_along_axis', 'xp_unsupported_param_msg', 'xp_vector_norm']
SCIPY_ARRAY_API: str | bool = ...
SCIPY_DEVICE = ...
_GLOBAL_CONFIG = ...
Array: TypeAlias = Any
ArrayLike: TypeAlias = Array | npt.ArrayLike
def array_namespace(*arrays: Array) -> ModuleType:
    """Get the array API compatible namespace for the arrays xs.

    Parameters
    ----------
    *arrays : sequence of array_like
        Arrays used to infer the common namespace.

    Returns
    -------
    namespace : module
        Common namespace.

    Notes
    -----
    Thin wrapper around `array_api_compat.array_namespace`.

    1. Check for the global switch: SCIPY_ARRAY_API. This can also be accessed
       dynamically through ``_GLOBAL_CONFIG['SCIPY_ARRAY_API']``.
    2. `_compliance_scipy` raise exceptions on known-bad subclasses. See
       its definition for more details.

    When the global switch is False, it defaults to the `numpy` namespace.
    In that case, there is no compliance check. This is a convenience to
    ease the adoption. Otherwise, arrays must comply with the new rules.
    """
    ...

def xp_copy(x: Array, *, xp: ModuleType | None = ...) -> Array:
    """
    Copies an array.

    Parameters
    ----------
    x : array

    xp : array_namespace

    Returns
    -------
    copy : array
        Copied array

    Notes
    -----
    This copy function does not offer all the semantics of `np.copy`, i.e. the
    `subok` and `order` keywords are not used.
    """
    ...

def xp_assert_equal(actual, desired, *, check_namespace=..., check_dtype=..., check_shape=..., check_0d=..., err_msg=..., xp=...): # -> Any | None:
    ...

def xp_assert_close(actual, desired, *, rtol=..., atol=..., check_namespace=..., check_dtype=..., check_shape=..., check_0d=..., err_msg=..., xp=...): # -> Any | None:
    ...

def xp_assert_less(actual, desired, *, check_namespace=..., check_dtype=..., check_shape=..., check_0d=..., err_msg=..., verbose=..., xp=...): # -> Any | None:
    ...

def assert_array_almost_equal(actual, desired, decimal=..., *args, **kwds): # -> Any | None:
    """Backwards compatible replacement. In new code, use xp_assert_close instead.
    """
    ...

def assert_almost_equal(actual, desired, decimal=..., *args, **kwds): # -> Any | None:
    """Backwards compatible replacement. In new code, use xp_assert_close instead.
    """
    ...

def xp_unsupported_param_msg(param: Any) -> str:
    ...

def is_complex(x: Array, xp: ModuleType) -> bool:
    ...

def get_xp_devices(xp: ModuleType) -> list[str] | list[None]:
    """Returns a list of available devices for the given namespace."""
    ...

def scipy_namespace_for(xp: ModuleType) -> ModuleType | None:
    """Return the `scipy`-like namespace of a non-NumPy backend

    That is, return the namespace corresponding with backend `xp` that contains
    `scipy` sub-namespaces like `linalg` and `special`. If no such namespace
    exists, return ``None``. Useful for dispatching.
    """
    ...

def xp_moveaxis_to_end(x: Array, source: int, /, *, xp: ModuleType | None = ...) -> Array:
    ...

def xp_copysign(x1: Array, x2: Array, /, *, xp: ModuleType | None = ...) -> Array:
    ...

def xp_sign(x: Array, /, *, xp: ModuleType | None = ...) -> Array:
    ...

def xp_vector_norm(x: Array, /, *, axis: int | tuple[int] | None = ..., keepdims: bool = ..., ord: int | float = ..., xp: ModuleType | None = ...) -> Array:
    ...

def xp_ravel(x: Array, /, *, xp: ModuleType | None = ...) -> Array:
    ...

def xp_real(x: Array, /, *, xp: ModuleType | None = ...) -> Array:
    ...

def xp_take_along_axis(arr: Array, indices: Array, /, *, axis: int = ..., xp: ModuleType | None = ...) -> Array:
    ...

def xp_broadcast_promote(*args, ensure_writeable=..., force_floating=..., xp=...): # -> list[Any]:
    ...

def xp_float_to_complex(arr: Array, xp: ModuleType | None = ...) -> Array:
    ...

