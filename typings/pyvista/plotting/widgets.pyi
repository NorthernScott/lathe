"""
This type stub file was generated by pyright.
"""

import pathlib
import pyvista
from typing import Sequence, TYPE_CHECKING
from pyvista.core._typing_core._array_like import NumpyArray

"""
This type stub file was generated by pyright.
"""
if TYPE_CHECKING:
    ...
class WidgetHelper:
    """An internal class to manage widgets.

    It also manages and other helper methods involving widgets.

    """
    def __init__(self, *args, **kwargs) -> None:
        """Initialize widget helper."""
        ...
    
    def add_box_widget(self, callback, bounds=..., factor=..., rotation_enabled=..., color=..., use_planes=..., outline_translation=..., pass_widget=..., interaction_event=...):
        """Add a box widget to the scene.

        This is useless without a callback function. You can pass a
        callable function that takes a single argument, the PolyData
        box output from this widget, and performs a task with that
        box.

        Parameters
        ----------
        callback : callable
            The method called every time the box is updated. This has
            two options: Take a single argument, the ``PolyData`` box
            (default) or if ``use_planes=True``, then it takes a
            single argument of the plane collection as a ``vtkPlanes``
            object.

        bounds : tuple(float)
            Length 6 tuple of the bounding box where the widget is
            placed.

        factor : float, optional
            An inflation factor to expand on the bounds when placing.

        rotation_enabled : bool, optional
            If ``False``, the box widget cannot be rotated and is
            strictly orthogonal to the Cartesian axes.

        color : ColorLike, optional
            Either a string, rgb sequence, or hex color string.
            Defaults to :attr:`pyvista.global_theme.font.color
            <pyvista.plotting.themes._Font.color>`.

        use_planes : bool, optional
            Changes the arguments passed to the callback to the planes
            that make up the box.

        outline_translation : bool, optional
            If ``False``, the box widget cannot be translated and is
            strictly placed at the given bounds.

        pass_widget : bool, optional
            If ``True``, the widget will be passed as the last
            argument of the callback.

        interaction_event : vtk.vtkCommand.EventIds, str, optional
            The VTK interaction event to use for triggering the
            callback. Accepts either the strings ``'start'``, ``'end'``,
            ``'always'`` or a ``vtk.vtkCommand.EventIds``.

            .. versionchanged:: 0.38.0
               Now accepts either strings or ``vtk.vtkCommand.EventIds``.

        Returns
        -------
        vtk.vtkBoxWidget
            Box widget.

        Examples
        --------
        Shows an interactive box that is used to resize and relocate a sphere.

        >>> import pyvista as pv
        >>> import numpy as np
        >>> plotter = pv.Plotter()
        >>> def simulate(widget):
        ...     bounds = widget.bounds
        ...     new_center = np.array(
        ...         [
        ...             (bounds[0] + bounds[1]) / 2,
        ...             (bounds[2] + bounds[3]) / 2,
        ...             (bounds[4] + bounds[5]) / 2,
        ...         ]
        ...     )
        ...     new_radius = (
        ...         min(
        ...             (bounds[1] - bounds[0]) / 2,
        ...             (bounds[3] - bounds[2]) / 2,
        ...             (bounds[5] - bounds[4]) / 2,
        ...         )
        ...         - 0.3
        ...     )
        ...     sphere = pv.Sphere(new_radius, new_center)
        ...     _ = plotter.add_mesh(sphere, name="Sphere")
        ...
        >>> _ = plotter.add_box_widget(callback=simulate)
        >>> plotter.show()

        """
        ...
    
    def clear_box_widgets(self):
        """Remove all of the box widgets."""
        ...
    
    def add_mesh_clip_box(self, mesh, invert=..., rotation_enabled=..., widget_color=..., outline_translation=..., merge_points=..., crinkle=..., interaction_event=..., **kwargs):
        """Clip a mesh using a box widget.

        Add a mesh to the scene with a box widget that is used to clip
        the mesh interactively.

        The clipped mesh is saved to the ``.box_clipped_meshes`` attribute on
        the plotter.

        Parameters
        ----------
        mesh : pyvista.DataSet or vtk.vtkAlgorithm
            The input dataset to add to the scene and clip or algorithm that
            produces said mesh.

        invert : bool, optional
            Flag on whether to flip/invert the clip.

        rotation_enabled : bool, optional
            If ``False``, the box widget cannot be rotated and is strictly
            orthogonal to the cartesian axes.

        widget_color : ColorLike, optional
            Color of the widget.  Either a string, RGB sequence, or
            hex color string.  For example:

            * ``color='white'``
            * ``color='w'``
            * ``color=[1.0, 1.0, 1.0]``
            * ``color='#FFFFFF'``

        outline_translation : bool, optional
            If ``False``, the plane widget cannot be translated and is
            strictly placed at the given bounds.

        merge_points : bool, optional
            If ``True`` (default), coinciding points of independently
            defined mesh elements will be merged.

        crinkle : bool, optional
            Crinkle the clip by extracting the entire cells along the clip.

        interaction_event : vtk.vtkCommand.EventIds, str, optional
            The VTK interaction event to use for triggering the
            callback. Accepts either the strings ``'start'``, ``'end'``,
            ``'always'`` or a ``vtk.vtkCommand.EventIds``.

            .. versionchanged:: 0.38.0
               Changed from ``event_type`` to ``interaction_event`` and now
               accepts either strings and ``vtk.vtkCommand.EventIds``.

        **kwargs : dict, optional
            All additional keyword arguments are passed to
            :func:`Plotter.add_mesh` to control how the mesh is
            displayed.

        Returns
        -------
        vtk.vtkActor
            VTK actor of the mesh.

        Examples
        --------
        Shows an interactive clip box.

        >>> import pyvista as pv
        >>> mesh = pv.ParametricConicSpiral()
        >>> pl = pv.Plotter()
        >>> _ = pl.add_mesh_clip_box(mesh, color='white')
        >>> pl.show()

        For a full example see :ref:`box_widget_example`.

        """
        ...
    
    def add_plane_widget(self, callback, normal=..., origin=..., bounds=..., factor=..., color=..., assign_to_axis=..., tubing=..., outline_translation=..., origin_translation=..., implicit=..., pass_widget=..., test_callback=..., normal_rotation=..., interaction_event=..., outline_opacity=...):
        """Add a plane widget to the scene.

        This is useless without a callback function. You can pass a
        callable function that takes two arguments, the normal and
        origin of the plane in that order output from this widget, and
        performs a task with that plane.

        Parameters
        ----------
        callback : callable
            The method called every time the plane is updated. Takes
            two arguments, the normal and origin of the plane in that
            order.

        normal : str or tuple(float)
            The starting normal vector of the plane.

        origin : tuple(float)
            The starting coordinate of the center of the plane.

        bounds : tuple(float)
            Length 6 tuple of the bounding box where the widget is placed.

        factor : float, optional
            An inflation factor to expand on the bounds when placing.

        color : ColorLike, optional
            Either a string, rgb list, or hex color string.

        assign_to_axis : str or int, optional
            Assign the normal of the plane to be parallel with a given
            axis: options are ``(0, 'x')``, ``(1, 'y')``, or ``(2,
            'z')``.

        tubing : bool, optional
            When using an implicit plane wiget, this controls whether
            or not tubing is shown around the plane's boundaries.

        outline_translation : bool, optional
            If ``False``, the plane widget cannot be translated and is
            strictly placed at the given bounds. Only valid when using
            an implicit plane.

        origin_translation : bool, optional
            If ``False``, the plane widget cannot be translated by its
            origin and is strictly placed at the given origin. Only
            valid when using an implicit plane.

        implicit : bool, optional
            When ``True``, a ``vtkImplicitPlaneWidget`` is used and
            when ``False``, a ``vtkPlaneWidget`` is used.

        pass_widget : bool, optional
            If ``True``, the widget will be passed as the last
            argument of the callback.

        test_callback : bool, optional
            If ``True``, run the callback function after the widget is
            created.

        normal_rotation : bool, optional
            Set the opacity of the normal vector arrow to 0 such that
            it is effectively disabled. This prevents the user from
            rotating the normal. This is forced to ``False`` when
            ``assign_to_axis`` is set.

        interaction_event : vtk.vtkCommand.EventIds, str, optional
            The VTK interaction event to use for triggering the
            callback. Accepts either the strings ``'start'``, ``'end'``,
            ``'always'`` or a ``vtk.vtkCommand.EventIds``.

            .. versionchanged:: 0.38.0
               Now accepts either strings and ``vtk.vtkCommand.EventIds``.

        outline_opacity : bool or float, optional
            Set the visible of outline. Only valid when using
            an implicit plane. Either a bool or float.

            .. versionadded:: 0.44.0

        Returns
        -------
        vtk.vtkImplicitPlaneWidget or vtk.vtkPlaneWidget
            Plane widget.

        Examples
        --------
        Shows an interactive plane moving along the x-axis in the random-hill example, which is used to mark the max altitude
        at a particular distance x.

        >>> import pyvista as pv
        >>> from pyvista import examples
        >>> mesh = examples.load_random_hills()
        >>> pl = pv.Plotter()
        >>> _ = pl.add_mesh(mesh)
        >>> def callback(normal, origin):
        ...     slc = mesh.slice(normal=normal, origin=origin)
        ...     origin = list(origin)
        ...     origin[2] = slc.bounds[5]
        ...     peak_plane = pv.Plane(
        ...         center=origin,
        ...         direction=[0, 0, 1],
        ...         i_size=20,
        ...         j_size=20,
        ...     )
        ...     _ = pl.add_mesh(
        ...         peak_plane, name="Peak", color='red', opacity=0.4
        ...     )
        ...
        >>> _ = pl.add_plane_widget(callback, normal_rotation=False)
        >>> pl.show()

        """
        ...
    
    def clear_plane_widgets(self):
        """Remove all of the plane widgets."""
        ...
    
    def add_mesh_clip_plane(self, mesh, normal=..., invert=..., widget_color=..., value=..., assign_to_axis=..., tubing=..., origin_translation=..., outline_translation=..., implicit=..., normal_rotation=..., crinkle=..., interaction_event=..., origin=..., outline_opacity=..., **kwargs):
        """Clip a mesh using a plane widget.

        Add a mesh to the scene with a plane widget that is used to clip
        the mesh interactively.

        The clipped mesh is saved to the ``.plane_clipped_meshes``
        attribute on the plotter.

        Parameters
        ----------
        mesh : pyvista.DataSet or vtk.vtkAlgorithm
            The input dataset to add to the scene and clip or algorithm that
            produces said mesh.

        normal : str or tuple(float), optional
            The starting normal vector of the plane.

        invert : bool, optional
            Flag on whether to flip/invert the clip.

        widget_color : ColorLike, optional
            Either a string, RGB list, or hex color string.

        value : float, optional
            Set the clipping value along the normal direction.
            The default value is 0.0.

        assign_to_axis : str or int, optional
            Assign the normal of the plane to be parallel with a given
            axis.  Options are ``(0, 'x')``, ``(1, 'y')``, or ``(2,
            'z')``.

        tubing : bool, optional
            When using an implicit plane wiget, this controls whether
            or not tubing is shown around the plane's boundaries.

        origin_translation : bool, optional
            If ``False``, the plane widget cannot be translated by its
            origin and is strictly placed at the given origin. Only
            valid when using an implicit plane.

        outline_translation : bool, optional
            If ``False``, the box widget cannot be translated and is
            strictly placed at the given bounds.

        implicit : bool, optional
            When ``True``, a ``vtkImplicitPlaneWidget`` is used and
            when ``False``, a ``vtkPlaneWidget`` is used.

        normal_rotation : bool, optional
            Set the opacity of the normal vector arrow to 0 such that
            it is effectively disabled. This prevents the user from
            rotating the normal. This is forced to ``False`` when
            ``assign_to_axis`` is set.

        crinkle : bool, optional
            Crinkle the clip by extracting the entire cells along the clip.

        interaction_event : vtk.vtkCommand.EventIds, str, optional
            The VTK interaction event to use for triggering the
            callback. Accepts either the strings ``'start'``, ``'end'``,
            ``'always'`` or a ``vtk.vtkCommand.EventIds``.

            .. versionchanged:: 0.38.0
               Now accepts either strings or ``vtk.vtkCommand.EventIds``.

        origin : tuple(float), optional
            The starting coordinate of the center of the plane.

        outline_opacity : bool or float, optional
            Set the visible of outline. Only valid when using
            an implicit plane. Either a bool or float.

            .. versionadded:: 0.44.0

        **kwargs : dict, optional
            All additional keyword arguments are passed to
            :func:`Plotter.add_mesh` to control how the mesh is
            displayed.

        Returns
        -------
        vtk.vtkActor
            VTK actor of the mesh.

        Examples
        --------
        Shows an interactive plane used to clip the mesh and store it.

        >>> import pyvista as pv
        >>> from pyvista import examples
        >>> vol = examples.load_airplane()
        >>> pl = pv.Plotter()
        >>> _ = pl.add_mesh_clip_plane(vol, normal=[0, -1, 0])
        >>> pl.show(cpos=[-2.1, 0.6, 1.5])
        >>> pl.plane_clipped_meshes  # doctest:+SKIP

        For a full example see :ref:`plane_widget_example`.

        """
        ...
    
    def add_volume_clip_plane(self, volume, normal=..., invert=..., widget_color=..., value=..., assign_to_axis=..., tubing=..., origin_translation=..., outline_translation=..., implicit=..., normal_rotation=..., interaction_event=..., origin=..., outline_opacity=..., **kwargs):
        """Clip a volume using a plane widget.

        Parameters
        ----------
        volume : pyvista.plotting.volume.Volume or pyvista.ImageData or pyvista.RectilinearGrid
            New dataset of type :class:`pyvista.ImageData` or
            :class:`pyvista.RectilinearGrid`, or the return value from
            :class:`pyvista.plotting.volume.Volume` from :func:`Plotter.add_volume`.

        normal : str or tuple(float), optional
            The starting normal vector of the plane.

        invert : bool, optional
            Flag on whether to flip/invert the clip.

        widget_color : ColorLike, optional
            Either a string, RGB list, or hex color string.

        value : float, optional
            Set the clipping value along the normal direction.
            The default value is 0.0.

        assign_to_axis : str or int, optional
            Assign the normal of the plane to be parallel with a given
            axis.  Options are ``(0, 'x')``, ``(1, 'y')``, or ``(2,
            'z')``.

        tubing : bool, optional
            When using an implicit plane wiget, this controls whether
            or not tubing is shown around the plane's boundaries.

        origin_translation : bool, optional
            If ``False``, the plane widget cannot be translated by its
            origin and is strictly placed at the given origin. Only
            valid when using an implicit plane.

        outline_translation : bool, optional
            If ``False``, the box widget cannot be translated and is
            strictly placed at the given bounds.

        implicit : bool, optional
            When ``True``, a ``vtkImplicitPlaneWidget`` is used and
            when ``False``, a ``vtkPlaneWidget`` is used.

        normal_rotation : bool, optional
            Set the opacity of the normal vector arrow to 0 such that
            it is effectively disabled. This prevents the user from
            rotating the normal. This is forced to ``False`` when
            ``assign_to_axis`` is set.

        interaction_event : vtk.vtkCommand.EventIds, optional
            The VTK interaction event to use for triggering the callback.

        origin : tuple(float), optional
            The starting coordinate of the center of the plane.

        outline_opacity : bool or float, optional
            Set the visible of outline. Only valid when using
            an implicit plane. Either a bool or float.

            .. versionadded:: 0.44.0

        **kwargs : dict, optional
            All additional keyword arguments are passed to
            :func:`Plotter.add_volume` to control how the volume is
            displayed. Only applicable if ``volume`` is either a
            :class:`pyvista.ImageData` and :class:`pyvista.RectilinearGrid`.

        Returns
        -------
        vtk.vtkPlaneWidget or vtk.vtkImplicitPlaneWidget
            The VTK plane widget depending on the value of ``implicit``.

        """
        ...
    
    def add_mesh_slice(self, mesh, normal=..., generate_triangles=..., widget_color=..., assign_to_axis=..., tubing=..., origin_translation=..., outline_translation=..., implicit=..., normal_rotation=..., interaction_event=..., origin=..., outline_opacity=..., **kwargs):
        """Slice a mesh using a plane widget.

        Add a mesh to the scene with a plane widget that is used to slice
        the mesh interactively.

        The sliced mesh is saved to the ``.plane_sliced_meshes`` attribute on
        the plotter.

        Parameters
        ----------
        mesh : pyvista.DataSet or vtk.vtkAlgorithm
            The input dataset to add to the scene and slice or algorithm that
            produces said mesh.

        normal : str or tuple(float), optional
            The starting normal vector of the plane.

        generate_triangles : bool, optional
            If this is enabled (``False`` by default), the output will be
            triangles otherwise, the output will be the intersection polygons.

        widget_color : ColorLike, optional
            Either a string, RGB sequence, or hex color string.  Defaults
            to ``'white'``.

        assign_to_axis : str or int, optional
            Assign the normal of the plane to be parallel with a given axis:
            options are (0, 'x'), (1, 'y'), or (2, 'z').

        tubing : bool, optional
            When using an implicit plane wiget, this controls whether or not
            tubing is shown around the plane's boundaries.

        origin_translation : bool, optional
            If ``False``, the plane widget cannot be translated by its origin
            and is strictly placed at the given origin. Only valid when using
            an implicit plane.

        outline_translation : bool, optional
            If ``False``, the box widget cannot be translated and is strictly
            placed at the given bounds.

        implicit : bool, optional
            When ``True``, a ``vtkImplicitPlaneWidget`` is used and when
            ``False``, a ``vtkPlaneWidget`` is used.

        normal_rotation : bool, optional
            Set the opacity of the normal vector arrow to 0 such that it is
            effectively disabled. This prevents the user from rotating the
            normal. This is forced to ``False`` when ``assign_to_axis`` is set.

        interaction_event : vtk.vtkCommand.EventIds, optional
            The VTK interaction event to use for triggering the callback.

        origin : tuple(float), optional
            The starting coordinate of the center of the plane.

        outline_opacity : bool or float, optional
            Set the visible of outline. Only valid when using
            an implicit plane. Either a bool or float.

            .. versionadded:: 0.44.0

        **kwargs : dict, optional
            All additional keyword arguments are passed to
            :func:`Plotter.add_mesh` to control how the mesh is
            displayed.

        Returns
        -------
        vtk.vtkActor
            VTK actor of the mesh.

        Examples
        --------
        Shows an interactive plane used specifically for slicing.

        >>> import pyvista as pv
        >>> from pyvista import examples
        >>> pl = pv.Plotter()
        >>> mesh = examples.load_channels()
        >>> _ = pl.add_mesh(mesh.outline())
        >>> _ = pl.add_mesh_slice(mesh, normal=[1, 0, 0.3])
        >>> pl.show()

        For a full example see :ref:`plane_widget_example`.

        """
        ...
    
    def add_mesh_slice_orthogonal(self, mesh, generate_triangles=..., widget_color=..., tubing=..., interaction_event=..., **kwargs):
        """Slice a mesh with three interactive planes.

        Adds three interactive plane slicing widgets for orthogonal slicing
        along each cartesian axis.

        Parameters
        ----------
        mesh : pyvista.DataSet or vtk.vtkAlgorithm
            The input dataset to add to the scene and threshold or algorithm
            that produces said mesh.

        generate_triangles : bool, optional
            If this is enabled (``False`` by default), the output will be
            triangles otherwise, the output will be the intersection polygons.

        widget_color : ColorLike, optional
            Color of the widget.  Either a string, RGB sequence, or
            hex color string.  For example:

            * ``color='white'``
            * ``color='w'``
            * ``color=[1.0, 1.0, 1.0]``
            * ``color='#FFFFFF'``

        tubing : bool, optional
            When using an implicit plane wiget, this controls whether or not
            tubing is shown around the plane's boundaries.

        interaction_event : vtk.vtkCommand.EventIds, optional
            The VTK interaction event to use for triggering the callback.

        **kwargs : dict, optional
            All additional keyword arguments are passed to
            :func:`Plotter.add_mesh` to control how the mesh is
            displayed.

        Returns
        -------
        list
            List of vtk.vtkActor(s).

        Examples
        --------
        Shows an interactive plane sliced along each cartesian axis of the mesh.

        >>> import pyvista as pv
        >>> pl = pv.Plotter()
        >>> mesh = pv.Wavelet()
        >>> _ = pl.add_mesh(mesh.outline())
        >>> _ = pl.add_mesh_slice_orthogonal(mesh)
        >>> pl.show()

        """
        ...
    
    def add_line_widget(self, callback, bounds=..., factor=..., resolution=..., color=..., use_vertices=..., pass_widget=..., interaction_event=...):
        """Add a line widget to the scene.

        This is useless without a callback function. You can pass a
        callable function that takes a single argument, the PolyData
        line output from this widget, and performs a task with that
        line.

        Parameters
        ----------
        callback : callable
            The method called every time the line is updated. This has
            two options: Take a single argument, the ``PolyData`` line
            (default) or if ``use_vertices=True``, then it can take
            two arguments of the coordinates of the line's end points.

        bounds : tuple(float), optional
            Length 6 tuple of the bounding box where the widget is
            placed.

        factor : float, optional
            An inflation factor to expand on the bounds when placing.

        resolution : int, optional
            The number of points in the line created.

        color : ColorLike, optional
            Either a string, rgb sequence, or hex color string.

        use_vertices : bool, optional
            Changes the arguments of the callback method to take the end
            points of the line instead of a PolyData object.

        pass_widget : bool, default: False
            If ``True``, the widget will be passed as the last
            argument of the callback.

        interaction_event : vtk.vtkCommand.EventIds, optional
            The VTK interaction event to use for triggering the callback.

        Returns
        -------
        vtk.vtkLineWidget
            Created line widget.

        Examples
        --------
        Shows an interactive line widget to move the sliced object like in `add_mesh_slice` function.

        >>> import pyvista as pv
        >>> from pyvista import examples
        >>> import numpy as np
        >>> model = examples.load_channels()
        >>> pl = pv.Plotter()
        >>> _ = pl.add_mesh(model, opacity=0.4)
        >>> def move_center(pointa, pointb):
        ...     center = (np.array(pointa) + np.array(pointb)) / 2
        ...     normal = np.array(pointa) - np.array(pointb)
        ...     single_slc = model.slice(normal=normal, origin=center)
        ...
        ...     _ = pl.add_mesh(single_slc, name="slc")
        ...
        >>> _ = pl.add_line_widget(callback=move_center, use_vertices=True)
        >>> pl.show()

        """
        ...
    
    def clear_line_widgets(self):
        """Remove all of the line widgets."""
        ...
    
    def add_text_slider_widget(self, callback, data, value=..., pointa=..., pointb=..., color=..., interaction_event=..., style=...):
        """Add a text slider bar widget.

        This is useless without a callback function. You can pass a callable
        function that takes a single argument, the value of this slider widget,
        and performs a task with that value.

        Parameters
        ----------
        callback : callable
            The method called every time the slider is updated. This should take
            a single parameter: the float value of the slider.

        data : list
            The list of possible values displayed on the slider bar.

        value : float, optional
            The starting value of the slider.

        pointa : tuple(float), optional
            The relative coordinates of the left point of the slider on the
            display port.

        pointb : tuple(float), optional
            The relative coordinates of the right point of the slider on the
            display port.

        color : ColorLike, optional
            Either a string, RGB list, or hex color string.  Defaults
            to :attr:`pyvista.global_theme.font.color
            <pyvista.plotting.themes._Font.color>`.

        interaction_event : vtk.vtkCommand.EventIds, str, optional
            The VTK interaction event to use for triggering the
            callback. Accepts either the strings ``'start'``, ``'end'``,
            ``'always'`` or a ``vtk.vtkCommand.EventIds``.

            .. versionchanged:: 0.38.0
               Changed from ``event_type`` to ``interaction_event`` and now
               accepts either strings or ``vtk.vtkCommand.EventIds``.

        style : str, optional
            The name of the slider style. The list of available styles
            are in ``pyvista.global_theme.slider_styles``. Defaults to
            ``None``.


        Returns
        -------
        vtk.vtkSliderWidget
            The VTK slider widget configured to display text.

        """
        ...
    
    def add_slider_widget(self, callback, rng, value=..., title=..., pointa=..., pointb=..., color=..., pass_widget=..., interaction_event=..., style=..., title_height=..., title_opacity=..., title_color=..., fmt=..., slider_width=..., tube_width=...):
        """Add a slider bar widget.

        This is useless without a callback function. You can pass a
        callable function that takes a single argument, the value of
        this slider widget, and performs a task with that value.

        Parameters
        ----------
        callback : callable
            Called every time the slider is updated. This should take a single
            parameter: the float value of the slider. If ``pass_widget=True``,
            callable should take two parameters: the float value of the slider
            and the widget itself.

        rng : tuple(float)
            Length two tuple of the minimum and maximum ranges of the
            slider.

        value : float, optional
            The starting value of the slider.

        title : str, optional
            The string label of the slider widget.

        pointa : tuple(float), optional
            The relative coordinates of the left point of the slider
            on the display port.

        pointb : tuple(float), optional
            The relative coordinates of the right point of the slider
            on the display port.

        color : ColorLike, optional
            Either a string, RGB list, or hex color string.  Defaults
            to :attr:`pyvista.global_theme.font.color
            <pyvista.plotting.themes._Font.color>`.

        pass_widget : bool, optional
            If ``True``, the widget will be passed as the last
            argument of the callback.

        interaction_event : vtk.vtkCommand.EventIds, str, optional
            The VTK interaction event to use for triggering the
            callback. Accepts either the strings ``'start'``, ``'end'``,
            ``'always'`` or a ``vtk.vtkCommand.EventIds``.

            .. versionchanged:: 0.38.0
               Changed from ``event_type`` to ``interaction_event`` and now accepts
               either strings or ``vtk.vtkCommand.EventIds``.

        style : str, optional
            The name of the slider style. The list of available styles
            are in ``pyvista.global_theme.slider_styles``. Defaults to
            ``None``.

        title_height : float, optional
            Relative height of the title as compared to the length of
            the slider.

        title_opacity : float, optional
            Opacity of title. Defaults to 1.0.

        title_color : ColorLike, optional
            Either a string, RGB sequence, or hex color string.  Defaults
            to the value given in ``color``.

        fmt : str, optional
            String formatter used to format numerical data. Defaults
            to ``None``.

        slider_width : float, optional
            Normalized width of the slider. Defaults to the theme's slider width.

        tube_width : float, optional
            Normalized width of the tube. Defaults to the theme's tube width.

        Returns
        -------
        vtk.vtkSliderWidget
            Slider widget.

        Examples
        --------
        >>> import pyvista as pv
        >>> pl = pv.Plotter()
        >>> def create_mesh(value):
        ...     res = int(value)
        ...     sphere = pv.Sphere(
        ...         phi_resolution=res, theta_resolution=res
        ...     )
        ...     pl.add_mesh(sphere, name="sphere", show_edges=True)
        ...
        >>> slider = pl.add_slider_widget(
        ...     create_mesh,
        ...     [5, 100],
        ...     title="Resolution",
        ...     title_opacity=0.5,
        ...     title_color="red",
        ...     fmt="%0.9f",
        ...     title_height=0.08,
        ... )
        >>> pl.show()
        """
        ...
    
    def clear_slider_widgets(self):
        """Remove all of the slider widgets."""
        ...
    
    def add_mesh_threshold(self, mesh, scalars=..., invert=..., widget_color=..., preference=..., title=..., pointa=..., pointb=..., continuous=..., all_scalars=..., method=..., **kwargs):
        """Apply a threshold on a mesh with a slider.

        Add a mesh to the scene with a slider widget that is used to
        threshold the mesh interactively.

        The threshold mesh is saved to the ``.threshold_meshes`` attribute on
        the plotter.

        Parameters
        ----------
        mesh : pyvista.DataSet or vtk.vtkAlgorithm
            The input dataset to add to the scene and threshold or algorithm
            that produces said mesh.

        scalars : str, optional
            The string name of the scalars on the mesh to threshold and display.

        invert : bool, default: False
            Invert the threshold results. That is, cells that would have been
            in the output with this option off are excluded, while cells that
            would have been excluded from the output are included.

        widget_color : ColorLike, optional
            Color of the widget.  Either a string, RGB sequence, or
            hex color string.  For example:

            * ``color='white'``
            * ``color='w'``
            * ``color=[1.0, 1.0, 1.0]``
            * ``color='#FFFFFF'``

        preference : str, default: 'cell'
            When ``mesh.n_points == mesh.n_cells`` and setting
            scalars, this parameter sets how the scalars will be
            mapped to the mesh.  Default ``'cell'``, causes the
            scalars to be associated with the mesh cells.  Can be
            either ``'point'`` or ``'cell'``.

        title : str, optional
            The string label of the slider widget.

        pointa : sequence, default: (0.4, 0.9)
            The relative coordinates of the left point of the slider
            on the display port.

        pointb : sequence, default: (0.9, 0.9)
            The relative coordinates of the right point of the slider
            on the display port.

        continuous : bool, default: False
            If this is enabled (default is ``False``), use the continuous
            interval ``[minimum cell scalar, maximum cell scalar]``
            to intersect the threshold bound, rather than the set of
            discrete scalar values from the vertices.

        all_scalars : bool, default: False
            If using scalars from point data, all
            points in a cell must satisfy the threshold when this
            value is ``True``.  When ``False``, any point of the cell
            with a scalar value satisfying the threshold criterion
            will extract the cell. Has no effect when using cell data.

        method : str, default: 'upper'
            Set the threshold method for single-values, defining which
            threshold bounds to use. If the ``value`` is a range, this
            parameter will be ignored, extracting data between the two
            values. For single values, ``'lower'`` will extract data
            lower than the  ``value``. ``'upper'`` will extract data
            larger than the ``value``.

        **kwargs : dict, optional
            All additional keyword arguments are passed to ``add_mesh`` to
            control how the mesh is displayed.

        Returns
        -------
        vtk.vtkActor
            VTK actor of the mesh.

        """
        ...
    
    def add_mesh_isovalue(self, mesh, scalars=..., compute_normals=..., compute_gradients=..., compute_scalars=..., preference=..., title=..., pointa=..., pointb=..., widget_color=..., **kwargs):
        """Create a contour of a mesh with a slider.

        Add a mesh to the scene with a slider widget that is used to
        contour at an isovalue of the *point* data on the mesh
        interactively.

        The isovalue mesh is saved to the ``.isovalue_meshes``
        attribute on the plotter.

        .. warning::
            This will not work with :class:`pyvista.PointSet` as
            creating an isovalue is a dimension reducing operation
            on the geometry and point clouds are zero dimensional.
            This will similarly fail for point clouds in
            :class:`pyvista.PolyData`.

        Parameters
        ----------
        mesh : pyvista.DataSet or vtk.vtkAlgorithm
            The input dataset to add to the scene and contour or algorithm
            that produces said mesh.

        scalars : str, optional
            The string name of the scalars on the mesh to contour and display.

        compute_normals : bool, optional
            Enable or disable the computation of normals.  If the
            output data will be processed by filters that modify
            topology or geometry, it may be wise to disable computing
            normals.

        compute_gradients : bool, optional
            Enable or disable the computation of gradients.  If the
            output data will be processed by filters that modify
            topology or geometry, it may be wise to disable computing
            gradients.

        compute_scalars : bool, optional
            Enable or disable the computation of scalars.

        preference : str, optional
            When ``mesh.n_points == mesh.n_cells`` and setting
            scalars, this parameter sets how the scalars will be
            mapped to the mesh.  Default ``'point'``, causes the
            scalars will be associated with the mesh points.  Can be
            either ``'point'`` or ``'cell'``.

        title : str, optional
            The string label of the slider widget.

        pointa : sequence, optional
            The relative coordinates of the left point of the slider
            on the display port.

        pointb : sequence
            The relative coordinates of the right point of the slider
            on the display port.

        widget_color : ColorLike, optional
            Color of the widget.  Either a string, RGB sequence, or
            hex color string.  For example:

            * ``color='white'``
            * ``color='w'``
            * ``color=[1.0, 1.0, 1.0]``
            * ``color='#FFFFFF'``

        **kwargs : dict, optional
            All additional keyword arguments are passed to
            :func:`Plotter.add_mesh` to control how the mesh is
            displayed.

        Returns
        -------
        vtk.vtkActor
            VTK actor of the mesh.

        Examples
        --------
        Shows an interactive slider controlling the altitude of the contours.

        >>> import pyvista as pv
        >>> from pyvista import examples
        >>> pl = pv.Plotter()
        >>> mesh = examples.load_random_hills()
        >>> _ = pl.add_mesh(mesh, opacity=0.4)
        >>> _ = pl.add_mesh_isovalue(mesh)
        >>> pl.show()

        """
        ...
    
    def add_spline_widget(self, callback, bounds=..., factor=..., n_handles=..., resolution=..., color=..., show_ribbon=..., ribbon_color=..., ribbon_opacity=..., pass_widget=..., closed=..., initial_points=..., interaction_event=...):
        """Create and add a spline widget to the scene.

        Use the bounds argument to place this widget. Several "handles" are
        used to control a parametric function for building this spline. Click
        directly on the line to translate the widget.

        Parameters
        ----------
        callback : callable
            The method called every time the spline is updated. This passes a
            :class:`pyvista.PolyData` object to the callback function of the
            generated spline.

        bounds : sequence[float], optional
            Length 6 sequence of the bounding box where the widget is placed.

        factor : float, optional
            An inflation factor to expand on the bounds when placing.

        n_handles : int, optional
            The number of interactive spheres to control the spline's
            parametric function.

        resolution : int, optional
            The number of points in the spline created between all the handles.

        color : ColorLike, optional
            Either a string, RGB sequence, or hex color string.

        show_ribbon : bool, optional
            If ``True``, the poly plane used for slicing will also be shown.

        ribbon_color : ColorLike, optional
            Color of the ribbon.  Either a string, RGB sequence, or
            hex color string.

        ribbon_opacity : float, optional
            Opacity of ribbon. Defaults to 1.0 and must be between
            ``[0, 1]``.

        pass_widget : bool, optional
            If ``True``, the widget will be passed as the last argument of the
            callback.

        closed : bool, optional
            Make the spline a closed loop.

        initial_points : sequence, optional
            The points to initialize the widget placement. Must have
            same number of elements as ``n_handles``. If the first and
            last point are the same, this will be a closed loop
            spline.

        interaction_event : vtk.vtkCommand.EventIds, optional
            The VTK interaction event to use for triggering the callback.

        Returns
        -------
        vtk.vtkSplineWidget
            The newly created spline widget.

        Notes
        -----
        This widget has trouble displaying certain colors. Use only simple
        colors (white, black, yellow).

        """
        ...
    
    def clear_spline_widgets(self):
        """Remove all of the spline widgets."""
        ...
    
    def add_mesh_slice_spline(self, mesh, generate_triangles=..., n_handles=..., resolution=..., widget_color=..., show_ribbon=..., ribbon_color=..., ribbon_opacity=..., initial_points=..., closed=..., interaction_event=..., **kwargs):
        """Slice a mesh with a spline widget.

        Add a mesh to the scene with a spline widget that is used to slice
        the mesh interactively.

        The sliced mesh is saved to the ``.spline_sliced_meshes`` attribute on
        the plotter.

        Parameters
        ----------
        mesh : pyvista.DataSet or vtk.vtkAlgorithm
            The input dataset to add to the scene and slice along the spline
            or algorithm that produces said mesh.

        generate_triangles : bool, optional
            If this is enabled (``False`` by default), the output will be
            triangles otherwise, the output will be the intersection polygons.

        n_handles : int, optional
            The number of interactive spheres to control the spline's
            parametric function.

        resolution : int, optional
            The number of points to generate on the spline.

        widget_color : ColorLike, optional
            Color of the widget.  Either a string, RGB sequence, or
            hex color string.  For example:

            * ``color='white'``
            * ``color='w'``
            * ``color=[1.0, 1.0, 1.0]``
            * ``color='#FFFFFF'``

        show_ribbon : bool, optional
            If ``True``, the poly plane used for slicing will also be shown.

        ribbon_color : ColorLike, optional
            Color of the ribbon.  Either a string, RGB sequence, or
            hex color string.

        ribbon_opacity : float, optional
            Opacity of ribbon. Defaults to 1.0 and must be between
            ``[0, 1]``.

        initial_points : sequence, optional
            The points to initialize the widget placement. Must have same
            number of elements as ``n_handles``. If the first and last point
            are the same, this will be a closed loop spline.

        closed : bool, optional
            Make the spline a closed loop.

        interaction_event : vtk.vtkCommand.EventIds, optional
            The VTK interaction event to use for triggering the callback.

        **kwargs : dict, optional
            All additional keyword arguments are passed to
            :func:`Plotter.add_mesh` to control how the mesh is
            displayed.

        Returns
        -------
        vtk.vtkActor
            VTK actor of the mesh.

        """
        ...
    
    def add_measurement_widget(self, callback=..., color=...):
        """Interactively measure distance with a distance widget.

        Creates an overlay documenting the selected line and total
        distance between two mouse left-click interactions.

        The measurement overlay stays on the rendering until the
        widget is deleted. Only one measurement can be added by each
        widget instance.

        Parameters
        ----------
        callback : Callable[[tuple[float, float, float], [tuple[float, float, float], int], float]
            The method called every time the widget calculates a
            distance measurement. This callback receives the start
            point and end point as cartesian coordinate tuples
            and the calculated distance between the two points.

        color : ColorLike, optional
            The color of the measurement widget.

        Returns
        -------
        vtk.vtkDistanceWidget
            The newly created distance widget.

        """
        ...
    
    def clear_measure_widgets(self):
        """Remove all of the measurement widgets."""
        ...
    
    def add_sphere_widget(self, callback, center=..., radius=..., theta_resolution=..., phi_resolution=..., color=..., style=..., selected_color=..., indices=..., pass_widget=..., test_callback=..., interaction_event=...):
        """Add one or many sphere widgets to a scene.

        Use a sphere widget to control a vertex location.

        Parameters
        ----------
        callback : callable
            The function to call back when the widget is modified. It takes a
            single argument: the center of the sphere as an XYZ coordinate (a
            3-length sequence), unless ``pass_widget=True``, in which case the
            callback must accept the widget object as the second parameter.  If
            multiple centers are passed in the ``center`` parameter, the
            callback must also accept an index of that widget.

        center : sequence[float], optional
            The cartesian coordinate of the sphere's center when placing it in
            the scene. If more than one location is passed, then that many
            widgets will be added and the callback will also be passed the
            integer index of that widget.

        radius : float, optional
            The radius of the sphere.

        theta_resolution : int, optional
            Set the number of points in the longitude direction.

        phi_resolution : int, optional
            Set the number of points in the latitude direction.

        color : ColorLike, optional
            The color of the sphere's surface.  If multiple centers
            are passed, then this must be a list of colors.  Each
            color is either a string, rgb list, or hex color string.
            For example:

            * ``color='white'``
            * ``color='w'``
            * ``color=[1.0, 1.0, 1.0]``
            * ``color='#FFFFFF'``

        style : str, optional
            Representation style: ``'surface'`` or ``'wireframe'``.

        selected_color : ColorLike, optional
            Color of the widget when selected during interaction.

        indices : sequence[int], optional
            Indices to assign the sphere widgets.

        pass_widget : bool, optional
            If ``True``, the widget will be passed as the last
            argument of the callback.

        test_callback : bool, optional
            If ``True``, run the callback function after the widget is
            created.

        interaction_event : vtk.vtkCommand.EventIds, optional
            The VTK interaction event to use for triggering the callback.

        Returns
        -------
        vtk.vtkSphereWidget
            The sphere widget.

        """
        ...
    
    def clear_sphere_widgets(self):
        """Remove all of the sphere widgets."""
        ...
    
    def add_affine_transform_widget(self, actor, origin=..., start=..., scale=..., line_radius=..., always_visible=..., axes_colors=..., axes=..., release_callback=..., interact_callback=...):
        """Add a 3D affine transform widget.

        This widget allows interactive transformations including translation and
        rotation using the left mouse button.

        Parameters
        ----------
        actor : pyvista.Actor
            The actor to which the widget is attached to.
        origin : sequence[float], optional
            Origin of the widget. Default is the origin of the main actor.
        start : bool, default: True
            If True, start the widget immediately.
        scale : float, default: 0.15
            Scale factor for the widget relative to the length of the actor.
        line_radius : float, default: 0.02
            Relative radius of the lines composing the widget.
        always_visible : bool, default: True
            Make the widget always visible. Setting this to ``False`` will cause
            the widget geometry to be hidden by other actors in the plotter.
        axes_colors : tuple[ColorLike], optional
            Uses the theme by default. Configure the individual axis colors by
            modifying either the theme with ``pyvista.global_theme.axes.x_color =
            <COLOR>`` or setting this with a ``tuple`` as in ``('r', 'g', 'b')``.
        axes : numpy.ndarray, optional
            ``(3, 3)`` Numpy array defining the X, Y, and Z axes. By default
            this matches the default coordinate system.
        release_callback : callable, optional
            Call this method when releasing the left mouse button. It is passed
            the ``user_matrix`` of the actor.
        interact_callback : callable, optional
            Call this method when moving the mouse with the left mouse button
            pressed down and a valid movement actor selected. It is passed the
            ``user_matrix`` of the actor.

        Returns
        -------
        pyvista.widgets.AffineWidget3D
            The affine widget.

        Notes
        -----
        After interacting with the actor, the transform will be stored within
        :attr:`pyvista.Actor.user_matrix` but will not be applied to the
        dataset. Use this matrix in conjunction with
        :func:`pyvista.DataSetFilters.transform` to transform the dataset.

        Examples
        --------
        Add the 3d affine widget.

        >>> import pyvista as pv
        >>> pl = pv.Plotter()
        >>> actor = pl.add_mesh(pv.Sphere())
        >>> widget = pl.add_affine_transform_widget(actor)
        >>> pl.show()

        Access the transform from the actor.

        >>> actor.user_matrix
        array([[1., 0., 0., 0.],
               [0., 1., 0., 0.],
               [0., 0., 1., 0.],
               [0., 0., 0., 1.]])
        """
        ...
    
    def add_checkbox_button_widget(self, callback, value=..., position=..., size=..., border_size=..., color_on=..., color_off=..., background_color=...):
        """Add a checkbox button widget to the scene.

        This is useless without a callback function. You can pass a callable
        function that takes a single argument, the state of this button widget
        and performs a task with that value.

        Parameters
        ----------
        callback : callable
            The method called every time the button is clicked. This should take
            a single parameter: the bool value of the button.

        value : bool, default: False
            The default state of the button.

        position : sequence[float], default: (10.0, 10.0)
            The absolute coordinates of the bottom left point of the button.

        size : int, default: 50
            The size of the button in number of pixels.

        border_size : int, default: 5
            The size of the borders of the button in pixels.

        color_on : ColorLike, optional
            The color used when the button is checked. Default is ``'blue'``.

        color_off : ColorLike, optional
            The color used when the button is not checked. Default is ``'grey'``.

        background_color : ColorLike, optional
            The background color of the button. Default is ``'white'``.

        Returns
        -------
        vtk.vtkButtonWidget
            The VTK button widget configured as a checkbox button.

        Examples
        --------
        The following example generates a static image of the widget.

        >>> import pyvista as pv
        >>> mesh = pv.Sphere()
        >>> p = pv.Plotter()
        >>> actor = p.add_mesh(mesh)
        >>> def toggle_vis(flag):
        ...     actor.SetVisibility(flag)
        ...
        >>> _ = p.add_checkbox_button_widget(toggle_vis, value=True)
        >>> p.show()

        Download the interactive example at :ref:`checkbox_widget_example`.

        """
        ...
    
    def add_camera_orientation_widget(self, animate=..., n_frames=...):
        """Add a camera orientation widget to the active renderer.

        .. note::
           This widget requires ``vtk>=9.1.0``.

        Parameters
        ----------
        animate : bool, default: True
            Enable or disable jump-to-axis-view animation.

        n_frames : int, default: 20
            The number of frames to animate the jump-to-axis-viewpoint feature.

        Returns
        -------
        vtkCameraOrientationWidget
            Camera orientation widget.

        Examples
        --------
        Add a camera orientation widget to the scene.

        >>> import pyvista as pv
        >>> mesh = pv.Cube()
        >>> plotter = pv.Plotter()
        >>> _ = plotter.add_mesh(
        ...     mesh, scalars=range(6), show_scalar_bar=False
        ... )
        >>> _ = plotter.add_camera_orientation_widget()
        >>> plotter.show()

        """
        ...
    
    def clear_camera_widgets(self):
        """Remove all of the camera widgets."""
        ...
    
    def clear_button_widgets(self):
        """Remove all of the button widgets."""
        ...
    
    def add_logo_widget(self, logo: pyvista.ImageData | str | pathlib.Path | None = ..., position: tuple[float, float] | Sequence[float] | NumpyArray[float] = ..., size: tuple[float, float] | Sequence[float] | NumpyArray[float] = ..., opacity: float = ...):
        """Add a logo widget to the top of the viewport.

        If no logo is passed, the PyVista logo will be used.

        Parameters
        ----------
        logo : pyvista.ImageData or pathlib.Path, optional
            The logo to display. If a pathlike is passed, it is assumed to be a
            file path to an image.

        position : tuple(float), optional
            The position of the logo in the viewport. The first value is the
            horizontal position and the second value is the vertical position.
            Both values must be between 0 and 1.

        size : tuple(float), optional
            The size of the logo in the viewport. The first value is the
            horizontal size and the second value is the vertical size. Both
            values must be between 0 and 1.

        opacity : float, optional
            The opacity of the logo. Must be between 0 and 1.

        Returns
        -------
        vtkLogoWidget
            The logo widget.

        Examples
        --------
        Add a logo widget to the scene.

        >>> import pyvista as pv
        >>> pl = pv.Plotter()
        >>> _ = pl.add_logo_widget()
        >>> _ = pl.add_mesh(pv.Sphere(), show_edges=True)
        >>> pl.show()

        """
        ...
    
    def clear_logo_widgets(self):
        """Remove all of the logo widgets."""
        ...
    
    def add_camera3d_widget(self):
        """Add a camera3d widget allow to move the camera.

        .. note::
           This widget requires ``vtk>=9.3.0``.

        Returns
        -------
        vtkCamera3DWidget
            The camera3d widget.

        Examples
        --------
        Add a camera3d widget to the scene.

        >>> import pyvista as pv
        >>> sphere = pv.Sphere()
        >>> plotter = pv.Plotter(shape=(1, 2))
        >>> _ = plotter.add_mesh(sphere, show_edges=True)
        >>> plotter.subplot(0, 1)
        >>> _ = plotter.add_mesh(sphere, show_edges=True)
        >>> _ = plotter.add_camera3d_widget()
        >>> plotter.show(cpos=plotter.camera_position)

        """
        ...
    
    def clear_camera3d_widgets(self):
        """Remove all of the camera3d widgets."""
        ...
    
    def close(self):
        """Close the widgets."""
        ...
    


