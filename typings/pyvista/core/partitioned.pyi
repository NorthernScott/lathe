"""
This type stub file was generated by pyright.
"""

from collections.abc import Iterable, MutableSequence
from typing import TYPE_CHECKING, overload
from . import _vtk_core as _vtk
from .dataset import DataObject, DataSet

"""
This type stub file was generated by pyright.
"""
if TYPE_CHECKING:
    ...
class PartitionedDataSet(_vtk.vtkPartitionedDataSet, DataObject, MutableSequence):
    """Wrapper for the ``vtkPartitionedDataSet`` class.

    DataSet which composite dataset to encapsulates a dataset consisting of partitions.

    Examples
    --------
    >>> import pyvista as pv
    >>> data = [
    ...     pv.Sphere(center=(2, 0, 0)),
    ...     pv.Cube(center=(0, 2, 0)),
    ...     pv.Cone(),
    ... ]
    >>> partitions = pv.PartitionedDataSet(data)
    >>> len(partitions)
    3

    """
    if _vtk.vtk_version_info >= (9, 1):
        _WRITERS = ...
    def __init__(self, *args, **kwargs) -> None:
        """Initialize the PartitionedDataSet."""
        ...
    
    def wrap_nested(self):
        """Ensure that all nested data structures are wrapped as PyVista datasets.

        This is performed in place.

        """
        ...
    
    @overload
    def __getitem__(self, index: int) -> DataSet | None:
        ...
    
    @overload
    def __getitem__(self, index: slice) -> PartitionedDataSet:
        ...
    
    def __getitem__(self, index):
        """Get a partition by its index."""
        ...
    
    @overload
    def __setitem__(self, index: int, data: DataSet | None):
        ...
    
    @overload
    def __setitem__(self, index: slice, data: Iterable[DataSet | None]):
        ...
    
    def __setitem__(self, index: int | slice, data):
        """Set a partition with a VTK data object."""
        ...
    
    def __delitem__(self, index: int | slice) -> None:
        """Remove a partition at the specified index are not supported."""
        ...
    
    def __iter__(self) -> PartitionedDataSet:
        """Return the iterator across all partitions."""
        ...
    
    def __next__(self) -> DataSet | None:
        """Get the next partition from the iterator."""
        ...
    
    def insert(self, index: int, dataset: DataSet) -> None:
        """Insert data before index."""
        ...
    
    def pop(self, index: int = ...) -> None:
        """Pop off a partition at the specified index are not supported."""
        ...
    
    def __repr__(self) -> str:
        """Define an adequate representation."""
        ...
    
    def __str__(self) -> str:
        """Return the str representation of the multi partition."""
        ...
    
    def __len__(self) -> int:
        """Return the number of partitions."""
        ...
    
    def copy_meta_from(self, ido, deep):
        """Copy pyvista meta data onto this object from another object."""
        ...
    
    def copy(self, deep=...):
        """Return a copy of the PartitionedDataSet.

        Parameters
        ----------
        deep : bool, default: True
            When ``True``, make a full copy of the object.

        Returns
        -------
        pyvista.PartitionedDataSet
           Deep or shallow copy of the ``PartitionedDataSet``.

        Examples
        --------
        >>> import pyvista as pv
        >>> data = [
        ...     pv.Sphere(center=(2, 0, 0)),
        ...     pv.Cube(center=(0, 2, 0)),
        ...     pv.Cone(),
        ... ]
        >>> partitions = pv.PartitionedDataSet(data)
        >>> new_partitions = partitions.copy()
        >>> len(new_partitions)
        3

        """
        ...
    
    @property
    def n_partitions(self) -> int:
        """Return the number of partitions.

        Returns
        -------
        int
            The number of partitions.
        """
        ...
    
    @n_partitions.setter
    def n_partitions(self, n):
        ...
    
    def append(self, dataset):
        """Add a data set to the next partition index.

        Parameters
        ----------
        dataset : pyvista.DataSet
            Dataset to append to this partitioned dataset.
        """
        ...
    


